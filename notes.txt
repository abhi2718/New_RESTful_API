
// MongoDB Aggregation Framework --> https://www.youtube.com/watch?v=s44QWegr2l8&list=PLWkguCWKqN9OwcbdYm4nUIXnA2IoXX0LI&index=2
//Mongoose Crash Course - Beginner Through Advanced By Kyle -> https://www.youtube.com/watch?v=DZBGEVgL2eE
//MongoDB Update Queries: 01 Introduction to the Document Updates https://www.youtube.com/watch?v=8O4qTCHDmbU&list=PLWkguCWKqN9OncFtHmijyW0VS6f5BEKpV&index=1
mongoose :- 
mongoose is ODM i.e Object Data Mapping which convert the mongodb document into object so that node js can access methods and properties
// Use $elemMatch to find any record from array of objects ---> https://studio3t.com/knowledge-base/articles/filter-elements-from-mongodb-arrays/
Populate more than one properties :
const userInfo = await User.findById(user._id).populate(["following","userRef]);

Adding following in userSchema as array  of id and pushing new following -> 

const mongoose = require("mongoose"),
  bcrypt = require("bcrypt"),
  Schema = mongoose.Schema,
  userSchema = new Schema(
    {
      name: {
        type: String,
        require: true,
      },
      email: {
        type: String,
        require: true,
      },
      password: {
        type: String,
        require: true,
        select: false,
      },
      following: [{
        type: Schema.Types.ObjectId,
        ref:"User"
      }]
    },
    {
      timestamps: true,
    }
  );
userSchema.methods.encryptPassword = async function (password) {
  const salt = await bcrypt.genSalt(5);
  const hash = await bcrypt.hash(password, salt);
  return hash;
};
userSchema.methods.validatePassword = async function (candidatePassword) {
  const result = await bcrypt.compare(candidatePassword, this.password);
  return result;
};
module.exports = mongoose.model("User", userSchema);


exports.fllow = async(req, res, next) => { 
    try {
        req.user.following.push(req.params.id);
        await req.user.save();
        res.status(200).json({message:"success"})
    } catch (error) {
        next(error);
    }
}

# Important Operators of mongodb are 

$set operator replaces the value of a field with the specified value.
The $set
 operator expression has the following form:

{ $set: { <field1>: <value1>, ... } }
To specify a <field> in an embedded document or in an array, use dot notation.
Visit this link for more information => https://www.mongodb.com/docs/manual/reference/operator/update/set/

 
$unset
 operator deletes a particular field. Consider the following syntax:
{ $unset: { <field1>: "", ... } }

 The specified value in the $unset 
 expression (i.e. "") does not impact the operation.
 To specify a <field> in an embedded document or in an array, use dot notation.
 Visit this link for more information => https://www.mongodb.com/docs/manual/reference/operator/update/unset/#:~:text=The%20%24unset%20operator%20deletes%20a,an%20array%2C%20use%20dot%20notation.


$push
The $push operator appends a specified value to an array.

The $push
 operator has the form:
{ $push: { <field1>: <value1>, ... } }
To specify a <field> in an embedded document or in an array, use dot notation.
for more information => https://www.mongodb.com/docs/manual/reference/operator/update/push/

# Updating a document inside  array of object :-

   const user = await User.updateOne({
      _id: req.params.id,
      "following.id":req.params.id  <--- It will perform projection 
    }, {
      $set:{ "following.$.name":req.body.name },
    });


# $pull 
The $pull operator removes from an existing array all instances of a value or values that match a specified condition.

The $pull
operator has the form:
{ $pull: { <field1>: <value|condition>, <field2>: <value|condition>, ... } }
To specify a <field> in an embedded document or in an array, use dot notation.


# The validation applied to the user schema level will not work in case of 
 findByIdAndUpdate,
 updateOne,
 updateMany
 while in case of .save(),.create() it will work  

 age: {
        type: Number,
        require: false,
        validate: {
          validator: value => {
            if (value % 2 === 0) {
              return true;
            } else {
              return false;
            }
          },
          message:props => `${props.value} is not an even number`
        }
      }

MongoDB Operators :- 
visit link for more information -> https://www.mongodb.com/docs/manual/reference/operator/
Operators

Query and Projection Operators
Query operators provide ways to locate data within the database and projection operators modify how data is presented.
Update Operators
Update operators are operators that enable you to modify the data in your database or add additional data.
Aggregation Pipeline Stages
Available aggregation stages for Aggregation Pipeline.
Aggregation Pipeline Operators
Aggregation pipeline operations have a collection of operators available to define and manipulate documents in pipeline stages.

$where :- we can use js function to make custom query and projection 
visit link for more information -> https://www.mongodb.com/docs/manual/reference/operator/query/where/#mongodb-query-op.-where
const users = await User.find({
      $where: function () {
         return this.following.find(item => item.id === "64045593bc781c63ba0b1e66")
      },
});

we can write $where as follow 
exports.users = async (req, res, next) => {
  try {
    const users = await User.$where(function () {
      return this.name === "Abhishek Singh" && (this.age > 21 && this.age < 30)
    });
    res.status(200).json(users);
  } catch (err) {
    next(err);
  }
};

Implementing pagination 
The limit and skip will help in pagination
 exports.users = async (req, res, next) => {
  try {
    const users = await User.find().limit(4).skip(4);
    res.status(200).json({length: users.length,users});
  } catch (err) {
    next(err);
  }
};

Selectiong only desire field 
exports.users = async (req, res, next) => {
  try {
    const users = await User.find().select(["email","name"]);
    res.status(200).json({length: users.length,users});
  } catch (err) {
    next(err);
  }
};


# Making  methods on schema level 
userSchema.methods.encryptPassword = async function (password) {
  const salt = await bcrypt.genSalt(5);
  const hash = await bcrypt.hash(password, salt);
  return hash;
};
userSchema.methods.validatePassword = async function (candidatePassword) {
  const result = await bcrypt.compare(candidatePassword, this.password);
  return result;
};

userSchema.statics.findByName = function (name) {
  return this.find();
} 


Creation of virtual properties
userSchema.virtual("averageAge").get(function () {
  return this.age / 5
})

Middleware they associated with each document so we can call then on following events such as save,validate,remove 
// pre middleware for more information : schema.post('init', function(doc) {
  console.log('%s has been initialized from the db', doc._id);
});
schema.post('validate', function(doc) {
  console.log('%s has been validated (but not saved yet)', doc._id);
});
schema.post('save', function(doc) {
  console.log('%s has been saved', doc._id);
});
schema.post('remove', function(doc) {
  console.log('%s has been removed', doc._id);
});
userSchema.pre('save', function (next) {
  console.log("pre ", this.name);
  next();
})

// post Middleware for more information : https://mongoosejs.com/docs/middleware.html#post
userSchema.post('save', function (doc,next) { 
  console.log("post ", this.name);
  next();
})

schema.post('init', function(doc) {
  console.log('%s has been initialized from the db', doc._id);
});
schema.post('validate', function(doc) {
  console.log('%s has been validated (but not saved yet)', doc._id);
});
schema.post('save', function(doc) {
  console.log('%s has been saved', doc._id);
});
schema.post('remove', function(doc) {
  console.log('%s has been removed', doc._id);
});

// Aggregation Framework Tutorial

// Match Stage
// $match the operator is use to match the condation it is like find({})
db.persons.aggregate([
  {
    $match:{
      age:{
        $eq:20
      },
      eyeColor:"green"
    } 
  }
  ])

  // Group Stage
   // $group operator is use to group the element Note _id is mendatory 
  db.persons.aggregate([
  {
    $group:{
      _id:{
        age:"$age",  // "$age" is expression 
        newTags:"$tags",
        rating:{$sum:"$rating"} // 
      }
    }
  }
  ])

// counting the result
The syntax for count is  $count:"ageAndgender" here age and gender both are keys inside the _id 
  db.persons.aggregate([
  {
   $match:{
     gender:"female"
   }
  },
 

  {
    $group:{
      _id:{
        age:"$age",
        gender:"$gender"
      }
    }
  },
    {
    $count:"ageAndgender"
  },
  ])